---File Header---
File: README.md
Author: Chih-Hsuan Kao
Login: cs8bwagy
Email: c4kao@ucsd.edu
Date: Feb 10, 2018

1. Firstly I added the sayStuff() method to the Critter.java file. Then, when I
   used the newly generated Critters inside the main method to call the
   sayStuff() method, all of the objects print out "I am a Critter." with no
   exception. This is because Critter Class the the superclass of all classes in
   which those objects belong to. Secondly, since it's header is "protected void
   sayStuff()," the method is sharable for all subclasses within the same
   package. 

2. Since SadAnimal has no fight() method inside its class, it would inherit it
   from its superclass, which in this case is Critter class. Note that the fight
   method under Critter class is of protected type, so it can be inherited by
   its subclass withing same package. In Critter class, when the fight method is
   called, the critter would forfeit. This is what SadAnimal would do, based on
   the concept of inheritance. 

3. First note that the getColor() method is a protected type. When I commend out
   getColor() in HappyAnimal, what gets affected are HappyAnimal and its
   subclass. When HappyAnimal needs to call getColor(), it cannnot call the one
   inside it; instead, it calls the one in Critter class and it returns color
   black. Similarly, when its subclass Sloth and Elephant try to call getColor()
   they will return color black because they cannot get one from HappyAnimal
   class.

4. After adding one more public static String instance variable to
   SadAnimal.java, only SadAnimal objects and its subclass objects can have
   access to this instance variable without error messages. Otherwise, will get
   "error: cannot find symbol" message upon compilation. This is firstly
   because, the string is public, can be accessed in a class defined outside
   the Critter family; secondly, it's intuitive that the subclass of SadAnimal 
   would have access to the instance variables. 

---Program Description---

On how I test my critters, I mainly utilize the debug function in the simulation
to test out my codes. By checking the option "Debug Output" becore entering the
simulation screen, I was able to keep track of the output generated by each step
of each Critter. For example, when I was testing out my code on Elephant class,
I discovered my Elephants didn't perform as I expected. Then, I use
System.out.println to print out coordinates and see what's going wrong with my
codes, and then understand it was due to a misconception of x and y direciton in
the simulation screen. I also change the number of each critter from time to
time to see the behavior more clearly. 

After compiling each critter class successfully, I am able to run the
simulation. The simulation was executed by CritterMain. There are a bunch of
methods in CritterMain that take in different strings, different values, etc. to
run the file that I compiled. It is even able to throw exception if it
encounters error reading file, etc. Everytime I run the simulator, I chose
different critters by different amount, assigning different values to width and
height of the screen, etc to meet my needs when running the simulation. 


