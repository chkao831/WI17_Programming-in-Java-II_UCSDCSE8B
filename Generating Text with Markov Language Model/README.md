File: README.md
This file contains part 7 of the psa7
Name: Chih-Hsuan KAo
Login: cs8bwagy
Email: c4kao@ucsd.edu
Date: Mar 4, 2018
Sources of Help: N/A

//
7A. HIGH LEVEL PROGRAM DESCRIPTION (NO CS TERM)
    The way to run the program is simple. We have a main program called
    generator, by running it and telling it which text file we want to use the
    program on, we would be able to process the file and generate text that
    makes use of the Markov Language Model. 
    The program using the Model is useful because such a decision making process
    has many applications, and is wisely used in AI decision making and machine
    learning nowadays. Its outcome is partly random and partly under the control
    of a decision maker. 

//
7B. TESTING
    The way I tested my code step-by-step is to finish each method separately
    and did not move on to the next one until I passed the testcase that I
    generated on my own. The testfiles that I wrote are simple enough (with
    probably three sentences only) that I can sketch different cases on paper
    and compare them to the actual output generated by the model.
    Then, after completing all methods, I made use of
    the testers provided and the main programs, along with the longer texts to
    test out my codes. 

//
7C. QUESTIONS
    1. What is a HashMap?
        A hashmap is a map based collection class that is used for storing key and
    value pairs, making no guarantees as to the order of the map. 

    2. How is a HashMap different from an ArrayList?
        Arraylist implements list interface while hashmap is an implementation
        of map interface. Furthermore, arraylist stores the element's value
        alone and internally maintains the indexes for each element, while
        hashmap stores key and value pair and does not preserve order. 

    3. Do you recommend implementing the program with only ArrayLists instead of
       HashMaps? Why or why not?
        Definitely not. This program relies heavily on the hashmap, which is
        used to store key and value pairs, while arraylist cannot do so. 
        For example, we need to identify possible transitions and store
        transitions and associated frequencies in hashmaps, but with arraylists
        only, such a combination cannot be achieved. 

    4. Name one limitation of the Markov Model
        Markov decision making is consistent with the frequency distribution
        because it's more likely to select a common words than a rare word and
        preserves each individual word's probability of being selected. However,
        let's say we have a file in which every word appears just once, no
        apparent distribution is shown and the text generated by the model would
        probably not make any sense. 

    5. Text generated by a Markov Model sometimes does not make sense
       semantically. Why is that?
        The Markov decision making generates next words using probability and
        preserves the original distribution, and because of its random nature,
        its just putting sentences together based on the randomly number chosen
        given different probability, so it doesn't always make sense. 

    6. Generate fake news choosing a high degree for WordModel?
        I would choose a relatively high degree if I want to generate fake news
        that look similar. With a degree that is too low, the words generated
        don't make too much sense. The more recent words we consider when
        generating the next word, the more real our fake news would be. 

    7. Why assume prefix always exists in the HashMap in method generateNext()?
        We assume prefix always exists in the HashMap in this case, given that
        we have trained the model properly from text. This can be seen from the
        Generator.java file, in which we wrap around (extend around at the edge)
        the training text when trying to predict prefix at the end of text, by
        referencing the scanner to a new scanner which contains previous words
        when there's no next element in the old scanner. 
